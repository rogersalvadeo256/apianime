import { join, sep } from 'node:path';
import { sha1 } from 'crypto-hash';
import { decode, encode } from './bencode/index.js';
/**
 * sha1 of torrent file info. This hash is commenly used by torrent clients as the ID of the torrent.
 */
export async function hash(file) {
    const torrent = decode(file);
    return sha1(encode(torrent.info));
}
/**
 * data about the files the torrent contains
 */
export function files(file) {
    const torrent = decode(file);
    const result = {
        files: [],
        length: 0,
        lastPieceLength: 0,
        pieceLength: torrent.info['piece length'],
        pieces: [],
    };
    const files = torrent.info.files || [torrent.info];
    const name = (torrent.info['name.utf-8'] || torrent.info.name).toString();
    result.files = files.map((file, i) => {
        const parts = [name, ...(file['path.utf-8'] || file.path || [])].map(p => p.toString());
        return {
            path: join(sep, ...parts).slice(1),
            name: parts[parts.length - 1],
            length: file.length,
            offset: files.slice(0, i).reduce(sumLength, 0),
        };
    });
    result.length = files.reduce(sumLength, 0);
    const lastFile = result.files[result.files.length - 1];
    result.lastPieceLength =
        (lastFile && (lastFile.offset + lastFile.length) % result.pieceLength) || result.pieceLength;
    result.pieces = splitPieces(torrent.info.pieces);
    return result;
}
function sumLength(sum, file) {
    return sum + file.length;
}
function splitPieces(buf) {
    const pieces = [];
    for (let i = 0; i < buf.length; i += 20) {
        pieces.push(buf.slice(i, i + 20).toString('hex'));
    }
    return pieces;
}
/**
 * torrent file info
 */
export function info(file) {
    const torrent = decode(file);
    const result = {
        name: (torrent.info['name.utf-8'] || torrent.info.name).toString(),
        announce: [],
        urlList: [],
    };
    if (torrent.info.private !== undefined) {
        result.private = Boolean(torrent.info.private);
    }
    if (torrent['creation date']) {
        result.created = new Date(torrent['creation date'] * 1000);
    }
    if (torrent['created by']) {
        result.createdBy = torrent['created by'].toString();
    }
    if (Buffer.isBuffer(torrent.comment)) {
        result.comment = torrent.comment.toString();
    }
    // announce and announce-list will be missing if metadata fetched via ut_metadata
    if (Array.isArray(torrent['announce-list']) &&
        torrent['announce-list'] &&
        torrent['announce-list'].length > 0) {
        torrent['announce-list'].forEach((urls) => {
            urls.forEach((url) => {
                result.announce.push(url.toString());
            });
        });
    }
    else if (torrent.announce) {
        result.announce.push(torrent.announce.toString());
    }
    if (result.announce.length) {
        result.announce = Array.from(new Set(result.announce));
    }
    // web seeds
    if (Buffer.isBuffer(torrent['url-list'])) {
        // some clients set url-list to empty string
        torrent['url-list'] = torrent['url-list'].length > 0 ? [torrent['url-list']] : [];
    }
    result.urlList = (torrent['url-list'] || []).map((url) => url.toString());
    if (result.urlList.length) {
        result.urlList = Array.from(new Set(result.urlList));
    }
    return result;
}
